Copyright 2010 Phillip M Webb

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.




Introduction
============

Spring DBUnit provides integration between the Spring testing framework and the popular DBUnit project.  It allows you to setup and teardown database tables using simple annotations.  It also provides support for checking expected table data once a test completes.


Configuring the DbUnitTestExecutionListener
===========================================

To make use of the Spring DBUnit annotations you must first configure your tests to use the DbUnitTestExecutionListener class.  To do this you need to use the Spring @TestExecutionListeners annotation.  Generally, as well as DbUnitTestExecutionListener, you will also want to include the standard Spring listeners as well.  Here are the annotations for a typical JUnit 4 test:

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
		DirtiesContextTestExecutionListener.class,
		TransactionalTestExecutionListener.class,
		DbUnitTestExecutionListener.class })

See the Spring JavaDocs for details of the standard listeners.

In order to access the database, Spring DBUnit requires a bean to be registered in you test context XML file.  By default a bean named “dataSource” or “dbUnitDatabaseConnection” can be used (see the Advanced Configuration section below if you need to use another name).  The bean can reference either a IDatabaseConnection or more typically a standard Java DataSource.  Here is a typical configuration for accessing an in-memory hypersonic database:

<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
	<property name="driverClassName" value="org.hsqldb.jdbcDriver" />
	<property name="url" value="jdbc:hsqldb:mem:paging" />
	<property name="username" value="sa" />
	<property name="password" value="" />
</bean>

Once you have configured the DbUnitTestExecutionListener and provided the bean to access you database you can use the DBUnit annotations.


Setup and TearDown
==================

Note: You need to complete the steps from the configuration section above before any annotations can be used.  Without appropriate configuration DBUnit annotations will be silently ignored.

The @DatabaseSetup and @DatabaseTearDown annotations can be used to configure database table before tests execute and reset them once tests have completed.


Setup
=====

The @DatabaseSetup annotation indicates how database tables should be setup before test methods are run.  The annotation can be applied to individual test methods or to a whole class.  When applied at the class level the setup occurs before each method in the test.  The annotation value references a file that contains the table DataSet used when resetting the database.  Typically this is a standard DBUnit XML file, although it is possible to load custom formats (see “Writing a DataSet Loader” below).

Here is a typical setup annotation.  In this case a file named sampleData.xml is contained in the same package as the test class.

@DatabaseSetup("sampleData.xml")

It is also possible to reference specific resource locations, for example:
@DatabaseSetup("/META-INF/dbtest/sampleData.xml")

By default setup will perform a “Clean Insert” operation, this means that all data from tables referenced in the DataSet XML will be removed before inserting new rows.  The standard DBUnit operations are supported using type attribute.  See the JavaDocs for full details.


TearDown
========

The @DatabaseTearDown annotation can be used to reset database tables once a test has completed.  As with @DatabaseSetup the annotation can be applied at the method or class level.  When using @DatabaseTearDown use the value and type attributes in the same way as @DatabaseSetup.

Note:  If you are running a teardown in conjunction with a @Transactional test you may need to use an alternative configuration.  See the section on “Transactions” below.


Expected results
================

The @ExpectedDatabase annotation can be used to verify the contents of database once a test has completed.  You would typically use this annotation when a test performs an insert, update or delete.  You can apply the annotation on a single test method or a class.  When applied at the class level verification occurs after each test method.

The @ExpectedDatabase annotation takes a single attribute that references the DataSet file used to verify results.  Here is a typical example:

@ExpectedDatabase("expectedData.xml")

Note:  If you are using this annotation in conjunction with a @Transactional test you may need to use an alternative configuration.  See the section on “Transactions” below.


Transactions
============

If you are running @Transactional tests using the Spring TransactionalTestExecutionListener you may experience problems with transactions not being started before your data is setup, or being rolled back before expected results can be verified.  In order to support @Transactional tests with DBUnit you should use the TransactionDbUnitTestExecutionListener class.  

Note:  TransactionDbUnitTestExecutionListener provides both DBUnit and Transactional support.  When using TransactionDbUnitTestExecutionListener you must not use the TransactionalTestExecutionListener or DbUnitTestExecutionListener classes.  

Here are the annotations for a typical JUnit 4 test:

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
@Transactional
@TestExecutionListeners({ DependencyInjectionTestExecutionListener.class,
		DirtiesContextTestExecutionListener.class,
		TransactionalDbUnitTestExecutionListener.class })

Transactions start before @DatabaseSetup and end after @DatabaseTearDown and @ExpectedDatabase.


Advanced configuration
======================

The @DbUnitConfiguration annotation can be used if you need to configure advanced options for DBUnit.  

The databaseConnection attribute allows you to specify a specific bean name from the Spring Context that contains the database connection.   When not specified the names “dataSource” or “dbUnitDatabaseConnection” can be used.  The bean must be either an IDatabaseConnection or a DataSource.

The dataSetLoader attribute allows you to specify a custom loader that will be used when reading datasets.  See “Writing a DataSet Loader” below for details.


Custom IDatabaseConnections
===========================

In some situations you may need to create an IDatabaseConnection with a specific DBUnit configuration.  Unfortunately, the standard DBUnit DatabaseConfig class cannot be easily using with Spring.  In order to overcome this limitation, the DatabaseConfigBean provides an alternative method to configure a connection; with  standard getter/setter access provided for all configuration options.  The  DatabaseDataSourceConnectionFactoryBean accepts a configuration property and should be used to construct the final connection.  Here is a typical example:
  
<bean id="dbUnitDatabaseConfig" class="org.springframework.test.dbunit.bean.DatabaseConfigBean">
	<property name="skipOracleRecyclebinTables" value="true"/>
</bean>
	
<bean id="dbUnitDatabaseConnection" class="org.springframework.test.dbunit.bean.DatabaseDataSourceConnectionFactoryBean">
	<property name="databaseConfig" ref="dbUnitDatabaseConfig"/>
</bean>


Writing a DataSet Loader
========================

By default DBUnit datasets are loaded from flat XML files.  If you need to load data from another source you will need to write your own DataSet loader and configure your tests to use it.  Custom loaders must implement the DataSetLoader interface and provide an implementation of the loadDataSet method.  The AbstractDataSetLoader is also available and provides a convenient base class for most loaders.

Here is an example loader that reads data from a CSV formatted file.

public class CsvDataSetLoader extends AbstractDataSetLoader {
	protected IDataSet createDataSet(Resource resource) throws Exception {
		return new CsvURLDataSet(resource.getURL());
	}
}

To configure a test class to use the loader use the @DbUnitConfiguration annotation.

@DbUnitConfiguration(dataSetLoader=CsvDataSetLoader.class)


